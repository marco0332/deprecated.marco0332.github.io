# DB - 면접 대비

## 1. 무결성

#### Q. 무결성에 대해 말해보세요.

#### A. 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것.

- 개체 무결성 : 기본키는 NULL, 중복 허용X
- 참조 무결성 : 외래키는 NULL값이 올 수 있음. 부모 테이블의 기본키에 종속되어야 한다.
- 도메인 무결성 : 올바른 데이터 타입이 입력되었는지 확인
- 고유 무결성 : 해당 속성값은 모두 고유한 값을 가짐
- Null 무결성 : 특정 속성값에 Null 될 수 없는 제약조건
- 키 무결성 : 각 릴레이션에는 최소한 한 개의 키가 존재해야 한다는 제약조건

---

#### Q. 무결성을 유지해야하는 이유?

#### A. 무결성이 유지되어야 DB에 저장된 데이터 값과 실제값이 계속 일치할 수 있음.

## 2. Commit과 Rollback

#### Q. Commit과 Rollback에 대해 설명해보시오

#### A. Commit은 해당 트랜잭션으로 반영된 DB 변경사항을 <b>저장</b>하는 것이고, Rollback은 해당 트랜잭션으로 반영된 DB 변경사항을 <b>취소</b>하는 것

더 자세하게 Commit은 트랜잭션에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

Rollback은 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때 모든 연산을 취소(Undo)시키는 연산.

## 3. 정규화

#### Q. 정규화의 목적

#### A. 데이터의 중복을 최소화하는 것. 그리고 테이블의 삽입, 삭제, 갱신 과정에서 발생하는 이상현상을 방지하기 위함.

## 4. JOIN

- INNER JOIN : 조건에 만족하는 행들만 보여주는 것
- OUTER JOIN : 조건에 만족하지 않는 기준 테이블의 행 또한 포함하여 보여주는 것.

## 5. 트랜잭션

#### Q. 트랜잭션이란?

#### A. 데이터베이스의 상태를 바꾸는 기능을 수행하기 위한 작업의 단위

데이터 무결성으로 인해 데이터 작업시에 문제가 생겼을 경우 모든 데이터를 작업하기 이전 시점으로 원상 복구 시킨다. 즉, 트랜잭션은 모두 실행되거나 모두 실행되지 않는다.

---

#### Q. 트랜잭션의 성질?

#### A. ACID라 불리는 네 가지 성질이 있음.

- Atomicity(원자성) : 트랜잭션 내에서 실행한 작업들은 하나로 간주한다. 즉, 모두 성공 또는 모두 실패.
- Consistency(일관성) : 트랜잭션은 일관성 있는 DB 상태를 유지한다. 예를들어 유니크 제약이 걸린 데이터일 경우 일련의 쿼리가 종료된 후에도 유니크 제약에 만족해야 함.
- Isolation(독립성) : 수행 중인 트랜잭션이 완료되기 전에는 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
- Durability(영속성) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

---

#### Q. 트랜잭션을 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명하시오.

#### A. 갱신 내용 손실, 현황 파악 오류, 모순성, 연쇄 복귀

- 갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
- 현황 파악 오류 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
- 모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
- 연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션마저 롤백이 되는 문제

---

#### Q. 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법

#### A. 로킹 제어 기법을 사용한다.

어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock 시키고 트랜잭션이 완료될 때 해당 부분을 Unlock시키는 방법이다. 종류는 크게 두 가지가 있는데, 공유로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고, 배타로킹은 일기, 쓰기 모두 불가능한 것.

---

#### Q. 그렇다면 로킹 단위를 크게했을 때와 작게 했을 때의 차이점

#### A. 로킹 단위가 크면 관리가 쉽지만 병행성이 떨어진다. 로킹단위가 작으면 관리가 어렵고 오버헤드가 증가하지만 병행성이 증가한다.

---

#### Q. 로킹 제어가 일으킬 수 있는 문제점은?

#### A. 로킹단위에 따라 다르겠지만 트랜잭션의 직렬화 가능성이 높아진다. 또한 데드락이 발생할 수 있다.

---

#### Q. 그럼 데드락을 방지하려면?

#### A. 데드락 탐지, 혹은 회피 적용. 또는 로킹 제어기법이 아닌 타임스탬프 기법 사용

- 데드락 탐지 : 알고리즘을 통해 매번 데드락 여부를 검사해야 하므로 코스트가 크다.
- 데드락 회피 : 시분할 처리를 해서 T1이 끝나면 T2가 실행되도록.

Facebook처럼 write보다 read가 월등히 많은 경우 Read용 DB를 slave로 두고 load를 모두 몰아주고, write를 Master로 보내고 DB를 동기화 할 수 있다.

또 다른 해결기법인 타임스탬프는 트랜잭션의 식별자로 타임스탬프를 지정하며 순서를 미리 선택하는 방법이다. 트랜잭션이 대기하지 않고 바로 실행은 하나 높은 확률로 롤백이 일어나며 연쇄 복귀를 초래할 수 있다.

## 6. 데이터의 수가 엄청 많을 때 어떻게 튜닝할 것인가?

<a href="https://jojoldu.tistory.com/243">Index 설정 방법 정리 글</a>

<a href="http://www.itworld.co.kr/tags/2665/SQL/105792">튜닝 방법 글</a>

## 7. Index

#### Q. Index를 사용하는 이유?

#### A. 검색과 정렬 작업의 속도를 높이기 위한 기능

- 사용대상 : 데이터 필터링과 정렬에 사용되므로, 데이터를 특정한 순서로 자주 정렬한다면 인덱스를 사용하기에 적합.
- 단점 : 인덱스를 사용하면 데이터를 가져오는 작업의 성능은 향상시킬 수 있으나 데이터 삽입, 변경 등이 일어날 때 매번 인덱스가 변경되기 때문에 성능이 떨어진다. 또한 인덱스 파일을 별도로 만들어야함으로 파일의 크기가 늘어나고, 인덱스를 처음에 생성하는데 시간이 많이 소요될 수 있음.

---

#### Q. Index에 사용되는 자료구조?

#### A. 보통 B-Tree혹은 B+Tree이다.

- B-Tree

  B-Tree는 검색성능을 높이기 위한 Balanced-Tree 자료구조의 종류 중 하나로서 이진트리와 다르게 하나의 노드에 여러자료가 배치되고, 2개 이상의 자식노드를 가질 수 있는 Tree구조. 루트를 제외한 모든 노드의 자료수는 LIMIT / 2 개여야하며, 자식노드의 수는 (부모노드의 자료수 + 1)개여야하는 특징이 있다.

  따라서 삽입, 삭제시에도 트리 균형을 유지할 수 있는 특징과, 언제나 균등한 탐색속도를 보장하지만, 트리의 균형을 유지하기 위해 복잡한 연산을 해야하며 중위순회방식을 사용하기에 순회탐색이 비효율적이라는 단점이 있다.

- B+Tree

  B+Tree는 B-Tree에서 순회탐색의 비효율을 보완한 구조로서, 노드의 데이터들이 연결리스트로 연결되어있어 순차적 처리가 가능하며 순회탐색이 빠르다. 트리의 최하단 노드에만 데이터들이 연결리스트로 정렬되어 있으며 나머지 노드들은 키값만 가지고 있는 구조.

---

#### Q. Index 생성시 고려사항

#### A.

- 테이블의 전체 데이터 중 적은 양(최대 15% 정도)을 조회할 때 사용
- 테이블에 데이터가 적을 수록 인덱스의 효율은 떨어진다
- 데이터의 유일성이 높을수록, 데이터의 범위가 넓은수록 인덱스의 효율은 올라간다.
- NULL이 적은 컬럼이 인덱스 효율이 좋다.
- 결합 인덱스의 경우 자주 사용되는 컬럼을 앞쪽에 배치한다.

=> 변경이 잦은 컬럼 X, true/false 값을 갖는 중복도 높은 컬럼 X, where절과 join, order by등에 자주 사용되는 컬럼은 성능 향상 효과 O

## 8. NoSQL

#### Q. NoSQL이란?

#### A. 많은 양의 데이터를 효율적으로 처리하기 위해 등장

RDBMS보다 덜 제한적인 일관성 모델 이용. 매우 최적화된 키-값 저장 공간 사용. 많은 양의 데이터를 효율적으로 처리하기 위해 등장(분산처리, 빠른쓰기 및 데이터의 안정성), 분산형 구조를 통해 여러 대의 서버에 분산해 저장하고 분산시에는 데이터를 상호 복제에 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조를 가짐.

데이터의 중복을 허용하는 구조때문에 scale out 방식 중 하나인 샤딩(Sharding) 적용이 쉬워 서버 확장이 쉽다.

---

#### Q. NoSQL이 RDBMS와 다른점?

#### A. 스키마가 없고, NoSQL은 트랜잭션을 지원하지 않는다. 또한 분산처리의 기능을 쉽게 제공한다.

RDBMS란 키와 값의 관계를 나타내는 테이블로 이루어져 있으며, 데이터의 종속성을 관계로 표현하는 것. NoSQL은 테이블 형식 스키마를 사용하지 않는 데이터베이스. 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용하는 것이 특징. 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용한다.

---

#### Q. NoSQL의 장점?

#### A. 가장 큰 장점은 Join이 없는 것.

Join 처리가 없기 때문에 스케일 아웃을 통한 노드 확장이 용이하다. 또한 가변적인 데이터구조로 데이터를 저장할 수 있어 유연성이 높다.

단점으로는 다양하고 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없다.

---

#### Q. 어떤 상황에서 NoSQL을 쓰는 것이 적합한가?

#### A. 비정형 데이터를 저장해야할 때 가장 적합하다.

## 9. 샤딩

샤딩을 설명하기 전에 Scale Up/ Sacle Out부터 알아야 한다.

- Scale Up이란 서버 그 자체를 증강하는 것. 즉 리소스를 붙여서 용량을 키워 처리 능력을 향상시키는 것. 프로세서 자체를 고성능 모델, 고가의 장비로 옮겨놓는 것을 의미한다.
- Scale Out이란 접속된 서버의 대수를 늘려 처리 능력을 향상시키는 것. 서버의 가상화 기능을 사용하고 하나의 케이스 내에서 가상적으로 복수 서버를 구축해 스케일 아웃과 같은 효과를 제공할 수도 있다.

그럼 Scale Out은 어떤 경우에 적합할까?

- 높은 병렬성을 실현하기 쉬운 경우. 즉 다수의 요구를 동시 병행으로 처리할 필요가 있지만 개별적 처리는 단순한 경우 적합하다. 읽기 전용인 스케일 아웃 환경에 있어서는 처리 능력 향상과 가용성 증대라는 이점도 존재한다. 하나의 서버가 장애를 일으켜도 다른 서버로 즉시 처리를 계속할 수 있기 때문이다.

DB부하가 많을 때 처리하는 기술로 Scale Out 기술 중 하나가 바로 <b>Sharding</b>이다. 샤딩은 데이터 베이스가 저장하고 있는 테이블들을 테이블 단위로 분리하는 수직샤딩과, 테이블 자체를 분할하는 수평 샤딩이 있다.

- 수직 샤딩은 연속된 데이터에 대해서 범위별로 데이터를 나누는 방법.
- 수평 샤딩은 연속된 키가 아니라 카테고리와 같은 종류에 따라서 데이터를 수평적으로 분리하는 방법.

shared nothing 개념에 기반하여 구글에서 만든 구조이며, 여러 저장소에 분할 저장하기 때문에 동기화에 대한 이슈를 제거했고, 속도가 빠르다. 하지만 특정 저장소에 정해진 데이터가 저장되어있기에 데이터를 찾으려면 특정 저장소를 찾아가야한다는 문제점이 있으며, 하나의 DB 서버가 다운이 되면 복구할 수 없다는 문제가 있다. 이러한 문제는 커버링이라는 구성을 통해 하나의 DB 서버가 다운되었을 때 그것을 이어받아 처리하는 조치가 필요하다.