# SWExpertAcademy - 롤러코스터 _ D4

## - 문제내용

현재 속력이 v일 때, (a, b)인 레일을 통과하면 av + b의 속력으로 바뀌게 된다.
N개의 레일이 주어졌을 때, 어떻게 레일들을 배치해야 최종 속력을 최소화 할 수 있을까?
가장 작은 최종 속력을 1,000,000,007로 나눈 나머지를 출력하라.

## - 문제풀이

완전탐색을 한다고 했을 때

- N개의 레일을 재배열하는 방법을 N!가지가 있다 => O(N!)
  이 모든 경우에 대해서 실제로 구한다 => O(N)
  즉, 시간복잡도는 O(N! * N)이다.

  이런 느린 방법을 이용하면 작은 N에 대해서 해결할 수 있을까? 아니다.
  과정을 진행할 때 실제로 최종 속력 값을 구할수가 업삳. 왜냐하면 av+b꼴로 계속 진행하게 되면 숫자가 매우 커질 수 있기 때문이다.

- <b>정답 배치의 성질</b>
  즉, 실제로 배치 방법을 정하고 값을 구하는 것 자체가 불가능하다!
  다른 관점으로 문제를 접근을 시도해보자.
  정답은 분명히 존쟇나다. (N!을 모두 시도해본다면 당연하다.)

  아래의 수열을 정답 배치라고 생각하고, 이 배치의 성질을 생각해보자

  > (a_1,b_1) -> (a_2,b_2) -> ... -> (a_n-1,b_n-1) -> (a_n, b_n)

  위 배치는 정답 배치이다. 다른 임의의 배치는 위 배치보다 속력이 크거나 같다.
  i번째와 i-1번째를 뒤집은 아래 배치는 정답 배치보다 속력이 크거나 같다.

  > (a_1,b_1) -> ... -> (a_i+1,b_i+1) -> (a_i,b_i) -> ... -> (a_n,b_n)

  이를 이용하면 식을 유도할 수 있다.

  > 나머지 부분이 다 같으므로, (a_i+1,b_i+1)와 (a_i,b_i)를 이용해보자.
  >
  > (a_i,b_i) -> (a_i+1,b_i+1) <= (a_i+1,b_i+1) -> (a_i,b_i)
  >
  > a_i+1(a_iX + b_i) + b_i+1 <= a_i(a_i+1X + b_i+1) + b_i
  >
  > a_i+1 b_i + b_i+1 <= a_i b_i+1 + b_i
  >
  > (a_i+1 - 1) / (b_i+1)   <=   (a_i - 1) / b_i
  >
  > 
  > 즉, (a_i - 1) / b_i 값으로 내림차순 정렬한 배치가 정답 배치라는 것을 알 수 있다.