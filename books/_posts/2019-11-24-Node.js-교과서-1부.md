# 2019-11-24-Node.js 교과서 -1부-

2019.11.24 시작

## :book: 1부 (1장 ~ 8장)

### :books: 1장. 노드 시작하기

#### 1-1. 핵심 개념 이해하기

노드의 공식사이트에서는 노드를 다음과 같이 설명하고 있다.

> Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임입니다. Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.

##### 1-1-1. 서버

노드를 통해 다양한 자바스크립트 애플리케이션을 실행할 수 있지만, 노드는 서버 애플리케이션을 실행하는데 제일 많이 사용된다.

서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 혹은 프로그램을 의미하며, 클라이언트란 요청을 보내는 주체이다. 서버는 요청에 대한 응답만 하기 보다는 다른 서버에 요청을 보내는 경우도 있다.

노드는 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다. 다른 언어를 사용하지 않고 굳이 노드를 사용해서 서버를 만드는 이유는 [여기]( https://nodejs.org/ko/about/ )에 설명된 내용을 바탕으로 알아보자.

##### 1-1-2. 자바스크립트 런타임

노드는 자바스크립트 런타임이다. 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻하며, 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해준다.

기존에는 브라우저 위에서만 실행할 수 있었지만, 구글의 V8 엔진을 통해 빠른 실행 속도를 얻게 되면서 브라우저 외의 환경에서도 실행 가능하게 되었다.

노드는 V8과 libuv라는 라이브러리를 사용하는데, 이는 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있다.

##### 1-1-3. 이벤트 기반

이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 있다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해야 한다. 이것을 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고 표현한다.

노드는 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출하며, 다 처리하거나 발생 이벤트가 없다면 대기한다.

이벤트 기반 모델에는 이벤트 루프라는 개념이 등장한다. 여러 이벤트가 동시 발생했을 경우 콜백 함수 호출 순서를 이벤트 루프가 판단한다.

- 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수 관리, 실행 순서를 결정한다.
- 태스크 큐 : 이벤트 발생 후 호출되어야 할 콜백 함수들이 대기하는 공간이다. 이벤트 루프가 정한 순서대로 대기해서 콜백 큐라고도 부른다.
- 백그라운드 : 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳.

<b>이벤트 루프 작동 방식</b>

```javascript
function run() {
    console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```

결과는 다음과 같다.

> 시작
> 끝
> 3초 후 실행

작동 방식 순서는 다음과 같다.

1. 호출 스택에 main(), setTimeout()이 쌓인다.
2. setTimeout() 실행 시 콜백 run은 백그라운드로 간다.
3. 백그라운드에 있는 run은 3초 후에 태스크 큐로 보내진다.
4. 호출 스택 실행이 끝나서 비워졌을 때 이벤트 루프가 태스크 큐의 콜백을 호출 스택으로 가져온다.
5. 태스크 큐로부터 온 run이 실행되고, 실행 완료 후에 호출 스택에서 비워진다.

##### 1-1-4. 논블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리 가능하다. 오래 걸리는 함수를 백그라운드로 보내면 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식이다. 이 방식이 논블로킹 방식이다. 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 의미한다.

싱글 스레드라는 한계 때문에 자바스크립트에서는 보통 I/O 작업이 시간적 이득을 많이 본다. 현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있게되기 때문이다.

```javascript
function longRunningTask() {
    // 오래 걸리는 작업
    console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```

결과는 다음과 같다.

> 시작
> 다음 작업
> 작업 끝

**setTimeout(콜백, 0)** 은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나이다. 노드에서는 settimeout(콜백, 0) 대신 다른 방식을 주로 사용한다. setTimeout의 콜백 함수가 태스크 큐로 보내지므로 순서대로 실행되지 않는 것을 확인할 수 있다.

##### 1-1-5. 싱글 스레드

노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다. 자바스크립트와 노드에서 논블로킹이 중요한 이유는 싱글 스레드이기 때문이다. 한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다.

멀티 스레드가 싱글 스레드보다 좋아 보이지만, 항상 그런 것은 아니다. 예시를 들어보면,

> 음식점에 여러명이 손님이 왔을 경우 어떻게 대처할 것인지?

1. 싱글 스레드(점원), 블로킹 모델 - 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 한다. 그 후 당므 손님의 주문을 받는다. 이 구조에서는 다음 손님은 마냥 기다리고 있어야 한다.
2. 싱글 스레드(점원), 논블로킹 모델 - 점원이 주문을 받고 주방에 주문 내역을 넘긴 뒤, 다음 손님의 주문을 받는다. 요리가 끝나길 기다리지 않고 주문이 들어왔다는 것만 알려주는 방식. 주문한 순서와 서빙하는 순서가 일치하지 않을 수 있다.
3. 멀티 스레드, 블로킹 모델 - 점원이 한 명씩 맡아 주문을 받고 서빙한다. 싱글 스레드보다 좋은 방법인 것 같지만 장단점이 있다.
   - 장점 : 손님 한 명당 점원이 한 명일 경우 서빙에는 문제가 없다. 점원 한명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문.
   - 단점 : 손님의 수가 늘어날 수록 점원의 수도 늘어난다. 손님 수가 줄어들었을 때 노는 점원이 생긴다. 또한 점원을 새로 고용하거나 기존 직원을 해고하는 데는 비용이 발생한다.

노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있다. 하지만 멀티 스레딩이라기보다는 멀티 프로세싱에 가깝다.

- 프로세스는 운영체제에서 할당하는 작업의 단위. 노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스이다. 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 하나의 프로세스는 스레드를 여러개 가질 수 있다. 스레드들은 부모 프로세스의 자원을 공유한다. 즉 같은 메모리에 접근할 수 있다.

자바스크립트 언어가 싱글 스레드 특성을 띠고 있기 때문에 노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세스 방식을 선택함.

#### 1-2. 서버로서의 노드

노드 서버는 I/O가 많은 작업에 적합하다. 하지만 싱글 스레드이기 때문에 CPU 부하가 큰 작업에는 적합하지 않다. 또한 멀티 스레드 방식보다 상대적으로 쉽다. 하지만 스레드가 하나이기 때문에 에러로 인해 멈추지 않도록 잘 관리해야 한다. 에러 처리가 제대로 이루어지지 않으면 서버 전체가 멈추기 때문이다. 또한 웹 서버가 내장되어 있어 편리하지만, 서버 규모가 커지면 nginx 등의 웹 서버를 노드 서버와 연결해야 한다.

무엇보다 노드의 가장 큰 장점은 자바스크립트를 사용한다는 것이다. 웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있다. 이는 개발 생산성이 획기적으로 높아진 계기가 되었다. Go처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느리다. 그래도 극단적인 성능이 필요하지 않다면 이러한 단점은 생산성으로 극복 가능하다.