# SWExpertAcademy - 두 번 이상 등장하는 문자열_D4

## - 문제내용

주어진 문자열 S에서 두 번 이상 등장하는 가장 긴 문자열을 찾아라.

## - 문제풀이

현재의 최적화 문제를 결정 문제로 변환하자.

> 두 번이상 등장하는 가장 긴 부분문자열의 길이를 구하기
>
> => 두 번이상 등장하는 길이가 k인 문자열이 존재한다.

파라미터 k를 외부에서 선택하고 그 결과를 빠르게 알 수 있다면, 이분 탐색을 사용할 수 있다.
왜냐하면 어떤 k값을 기준으로 되는 부분과 안되는 부분이 나누어지기 때문(가장 긴 문자열이기 때문에) => O(logN)

그러면 이렇게 정해진 k에 대해서
모든 길이 k인 부분문자열에 대해 해시를 계산한다. => O(N)

그리고 중복된게 있는지 확인
=> 해시를 2^64범위에서 계산했으므로 배열에 체크하고 다시 접근했을 때 확인하는 방식으로는 중복 검사가 불가능하다. 그래서 모든 해시값을 정렬해주면 중복된 쌍은 반드시 연속해서 존재. 이에 O(NlogN)으로 정렬하고, O(N)에 다음 칸이랑 같은지 검사.

즉, O(logN) * O(N) + O(NlogN) = O(Nlog^2N)

## + 더 빠르게

1. Counting Sort: O(N)
   개수를 세어 정렬하기. 반드시 O(NlogN)이상이라고 증명된 비교 기반 정렬이 아니기에 O(N+d)라는 빠른 속도를 얻을 수 있다. 이때 d는 수의 범위이다. 그래서 d의 범위가 좁을 때 사용해야 유리하다.

   - 개수 세기
   - 누적합 구하기
   - <b>역순</b>으로 자리 지정

   => 그런데 만약 <pair>로 들어오고, key를 first로만 사용한다면?
   처음 배열에 있었던 순으로 정렬된다. 즉, Stable하다.

   이 문제에 적용할 때는, d가 문자열의 길이인 N이므로 O(N)이 유지된다.

2. Surfix Array
   BANANA : BANANA, ANANA, NANA, ANA, NA, A를 사전순으로 정렬하면?
   => A, ANA, ANANA, BANANA, ...


   s[i..]: s의 i번째 문자로부터 이루어진 부분 문자열
   s[i..t]: s의 i번째 문자부터 t개의 문자로 이루어진 부분 문자열.
   g[i]: s[i..t]의 등수
   라고 표기. 각 스텝마다 길이를 2배씩 늘리면서 부분 문자열 순위를 매긴다면

   | i       | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
   | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | s[i..1] | m    | i    | s    | s    | i    | s    | s    | i    | p    | i    |
   | g[i]    | 2    | 1    | 4    | 4    | 1    | 4    | 4    | 1    | 3    | 1    |
   | s[i..2] | mi   | is   | ss   | si   | is   | ss   | si   | ip   | pi   | i$   |
   | g[i]    | 4    | 3    | 7    | 6    | 3    | 7    | 6    | 2    | 5    | 1    |

   이 다음은 그 위에 표를 참고해서 순위를 매길 수 있다.
   근데 각 등수를 구할 때 그 전 단계에서 O(1)만에 찾을 수 있다.

   길이가 2t인 부분문자열들의 순위를 결정하는 단계에서
   g[i]와 g[j]가 같을 때 g[i+t]와 g[j+t]를 비교
   이 비교를 이용해서 정렬을 하면 O(NlogN)이므로 결과는 O(Nlog^2N) 되니까, counting sort를 이용해서 정렬.

   즉, g[i+t]를 기준으로 정렬을 하고, g[i]에 대해서 정렬을 하면 O(N) + O(N) = O(N)

3. Longest Common Prefix: O(N)
   Suffix array에서 이웃한 두 접미사 간의 최장 공통 접두사를 구하는 알고리즘

